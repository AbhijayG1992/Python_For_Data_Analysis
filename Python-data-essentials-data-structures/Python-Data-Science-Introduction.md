## ðŸ“… Applied AI Course Schedule (April 2025)

### ðŸ PYTHON

| Day            | Module                                     | Chapter                        | Topic                                                                                           |
|----------------|--------------------------------------------|--------------------------------|-------------------------------------------------------------------------------------------------|
| Day 1          | Python for Data Science                    | â€”                              | Keywords and identifiers, comments, indentation and statements, Variables and data types        |
| Day 1          | Python for Data Science                    | â€”                              | Standard Input and Output, Operators, Control flow: if else                                     |
| Day 2          | Python for Data Science                    | â€”                              | Control flow: while loop, Control flow: for loop                                                |
| Day 2          | Python for Data Science                    | â€”                              | Control flow: break and continue, **Revision: Python Basics**                                   |
| Day 3          | Module 1: Fundamentals of Programming      | Structures                     | Lists                                                                                           |
| Day 3          | Module 1: Fundamentals of Programming      | Structures                     | Tuples part 1, Tuples part 2, Data Sets, Dictionary                                             |
| Day 4          | Module 1: Fundamentals of Programming      | Structures                     | Strings, **Revision: Data Structures**                                                          |
| Day 5          | Python for Data Science â€“ Data Structures  | Functions                      | Introduction, Types of functions, Function arguments, Recursive functions                       |
| Day 6          | Python for Data Science â€“ Data Structures  | Functions                      | Lambda functions, Modules, Packages, File Handling                                              |
| Day 7          | Python for Data Science â€“ Data Structures  | Functions                      | Exception Handling, Debugging Python, **Revision: Functions**                                   |

### ðŸ—„ï¸ SQL

| Day            | Module                                     | Chapter                        | Topic                                                                                                                        |
|----------------|--------------------------------------------|--------------------------------|------------------------------------------------------------------------------------------------------------------------------|
| Day 8          | Module 1: Fundamentals of Programming      | SQL                            | Introduction to Databases, Why SQL?                                                                                          |
| Day 8          | Module 1: Fundamentals of Programming      | SQL                            | Execution of an SQL statement, IMDB dataset, Installing MySQL, Load IMDB data, USE, DESCRIBE, SHOW TABLES, SELECT            |
| Day 9          | Module 1: Fundamentals of Programming      | SQL                            | LIMIT, OFFSET, ORDER BY, DISTINCT, WHERE                                                                                     |
| Day 10         | Module 1: Fundamentals of Programming      | SQL                            | Comparison operators, NULL, Logical Operators, Aggregate Functions: COUNT, MIN, MAX, AVG, SUM                                |
| Day 11         | Module 1: Fundamentals of Programming      | SQL                            | GROUP BY, HAVING, ORDER BY keywords, Join and Natural Join, Inner, Left, Right and Outer joins                               |
| Day 12         | Module 1: Fundamentals of Programming      | SQL                            | Sub Queries/Nested Queries/Inner Queries, DML: INSERT, UPDATE, DELETE, DDL: CREATE TABLE, ALTER: ADD, MODIFY, DROP,          |
| Day 12         | Module 1: Fundamentals of Programming      | SQL                            | DDL: DROP TABLE, TRUNCATE, DELETE, Data Control Language: GRANT, REVOKE                                                      |



# Python Data Essentials: Python Introduction

## Course Overview

Hello, everyone. My name is Abhijay , and welcome to my course, **Python Data Essentials: Python Introduction**. I am an software professional (10+ YOE) who loves to teach online. Python is one of the most preferred languages when it comes to data science. 
When you are finished with this course, you will have an understanding of Python concepts and practical skills that are needed for getting started with data science. In this course, we are going to understand the fundamentals and basics of Python concepts that apply to the data science space.

### Major Topics Covered

- **Data Structures**: Learn about lists, dictionaries, tuples, and sets.
- **Operators**: Explore different types of operators in Python.
- **Packages**: Understand how to use and manage packages.
- **Identifiers**: Learn about naming conventions and identifiers in Python.

By the end of this course, you will have a clear understanding of Python fundamentals and basic concepts that apply to the field of data science.

### Prerequisites

Before beginning this course, you should be familiar with basic concepts such as:
- What is programming?
- Why should you learn to program?

From here, you should feel comfortable diving into data science with courses on the Python Data Essentials path. I hope you will join me on this journey to learn Python fundamentals and basic concepts with the **Python Data Essentials: Python Introduction** course.

---
# Python and Data Science

## Course Overview

### Python and Data Science

Hello everybody. Welcome to this class. In this lecture, we are going to do an introduction to Python, and we are going to discuss about Python and data science. So by the end of this lecture, you will have clarity as to what Python is. We are going to discuss the features of Python, different packages that are available for data science, and why Python is preferred for data science.

### Topics Covered

1. **Introduction to Python**:
   - What is Python?
   - Python as a powerful programming language.
   - Open source and freely available, even for commercial usage.
   - Use cases: web applications, desktop applications, automation, data science, and machine learning.

2. **Features of Python**:
   - **Object-Oriented**: Everything in Python is an object.
   - **Interpreted**: Execution is done line-by-line by the Python Interpreter.
   - **Portable**: Write code once and run it anywhere (Windows, Mac, Linux).
   - **Strong Support of Libraries and Packages**: Extensive developer community and availability of various libraries.

3. **Popular Data Science Packages**:
   - **NumPy**: Popular package for computing and data analysis.
   - **Matplotlib**: Powerful visualization package for plotting graphs and visualizing data.
   - **Pandas**: Used for data analysis and manipulation of datasets.
   - **SciPy**: Scientific computing in Python.

4. **Why Python for Data Science?**:
   - Wide range of packages and libraries available for data work.
   - Free to use.
   - Beginner-friendly with simple syntax.

---

## Installing Python

### Hands-on Demo: Installing Python

Hello everybody. Welcome to this class. In this lecture, we are going to install Python on our system. Follow along for a hands-on demo to download and install Python.

#### Installing Python on Windows:

1. **Open Windows PowerShell**:
   - Go to Start and search for PowerShell.
   - Open the PowerShell terminal.

2. **Check for Existing Python Installation**:
   - Run the command: `python3 --version`
   - If Python is not installed, you will see a message indicating that.

3. **Install Python from Microsoft Store**:
   - Run the command: `python3`
   - This will open the Microsoft Store, directing you to the Python app.
   - Click on "Get" to download and install Python.

4. **Verify Python Installation**:
   - Run the command: `python3 --version`
   - You should see the version number of Python installed.

#### Installing Python on Mac:

1. **Download Python**:
   - Search for "Python download" on Google.
   - Click on the official Python website link and download Python.

2. **Install Python**:
   - Double-click on the downloaded `.pkg` file.
   - Follow the on-screen instructions to complete the installation.

3. **Verify Python Installation**:
   - Open the Terminal application.
   - Run the command: `python3 --version`
   - You should see the version number of Python installed.

4. **Using Python Shell**:
   - Log into Python Shell by running the command: `python3`
   - Run simple Python commands within the shell (e.g., `print("Hello Python")`, `2+2`, `2*6`).

### Conclusion

By following these instructions, you should have Python installed and be able to run simple Python commands. The Python shell can be used as an interactive terminal to test and execute Python code.

---

# Different Python IDEs

## Course Overview

### Introduction to IDEs

Hello everybody. Welcome to this class. In this lecture, we are going to talk about different Python IDEs. Before that, we will discuss what IDEs are.

### What are IDEs?

IDE stands for Integrated Development Environment. An IDE is a tool that increases the productivity of developers by providing various features that assist in programming. Although you can use a text editor to write code, an IDE provides additional benefits such as:

- **Syntax Highlighting**: Makes code easier to read and understand.
- **Autocomplete**: Suggests code as you type, saving keystrokes and reducing syntax errors.
- **Debugging**: Tools to find and fix errors in your code.
- **Integrated Version Control**: Built-in support for version control systems like Git.

### Different Python IDEs

We will discuss various Python IDEs available in the market:

1. **PyCharm**:
   - **Official Website**: [JetBrains PyCharm](https://www.jetbrains.com/pycharm/)
   - Developed by JetBrains, PyCharm is a popular IDE with features like syntax highlighting, autocomplete, and debugging. It is available in two versions:
     - **PyCharm Professional Edition**: Paid version with advanced features.
     - **PyCharm Community Edition**: Free, open-source version suitable for learning Python.

2. **Atom IDE**:
   - Atom was maintained by GitHub. However, as of June 8, 2022, GitHub has announced it will no longer focus on Atom.
   - Atom was a popular IDE with features like syntax highlighting and a customizable interface, but it's no longer recommended for future use due to discontinued development.

3. **Visual Studio Code**:
   - **Official Website**: [Visual Studio Code](https://code.visualstudio.com/)
   - Developed by Microsoft, Visual Studio Code is a lightweight yet powerful IDE with features like Git integration, debugging, and a wide range of extensions.

4. **Jupyter Notebook**:
   - **Official Website**: [Jupyter.org](https://jupyter.org/)
   - Jupyter Notebook is a web-based IDE focused on data analysis and visualization. It is popular among data science professionals. It runs in the browser and offers an interactive environment for running Python code.

### Conclusion

By understanding the different Python IDEs and their features, you can choose the one that best suits your needs, whether you are a beginner or an advanced developer. In our course, we will be using Jupyter Notebook due to its popularity and focus on data science.

---
# Installing and Setting up Jupyter Notebook

## Introduction
This guide will walk you through the steps to install and set up Jupyter Notebook on your system.

## Prerequisites
- **Python**: Ensure Python is installed on your system.
- **Pip**: Pip is a package manager for Python packages. It is included with the latest versions of Python.

## Step-by-Step Guide

### 1. Install Jupyter Notebook
1. **Open Terminal (macOS) or PowerShell (Windows)**
2. **Run the following command**:
    ```bash
    pip install jupyter
    ```
    - This command uses the pip package manager to install Jupyter Notebook.
    - You should see a message saying `Successfully installed jupyter`.

### 2. Launch Jupyter Notebook
1. **Run the following command**:
    ```bash
    jupyter notebook
    ```
    - This command will launch Jupyter Notebook in your default web browser.
    - If the browser does not open automatically, copy the URL provided in the terminal and paste it into your browser.

### 3. Create a New Notebook
1. **Navigate to the Jupyter Notebook Interface in Your Browser**:
    - You will see the Jupyter web interface with a folder structure.
2. **Create a New Notebook**:
    - Click on `New` and select `Python 3`.
    - A new tab will open with the Jupyter Notebook interface.

### 4. Jupyter Notebook Interface
1. **Rename the Notebook**:
    - The default notebook name is `Untitled`.
    - Click on the name and rename it (e.g., `First Notebook`), then click `Rename`.
2. **Notebook Menu Bar**:
    - The menu bar contains various options like `File`, `Edit`, etc.
3. **Notebook Toolbar**:
    - The toolbar has buttons for common actions (e.g., save, add cell, delete cell).
    - Hover over each button to see more information.

### 5. Working with Checkpoints
1. **Save and Create Checkpoints**:
    - Click the save button or use the `File` menu to save and create a checkpoint.
    - You will see a message `Checkpoint created`.
2. **Revert to a Checkpoint**:
    - Go to `File` -> `Revert to Checkpoint` to revert to a previously saved version.

### 6. Adding and Running Code Cells
1. **Add a New Cell**:
    - Use the `+` button to add a new cell.
2. **Delete a Cell**:
    - Use the scissor icon to delete a cell.
3. **Run Python Code**:
    - Type Python code in a cell (e.g., `print("Hello World")`).
    - Press `Shift + Enter` to run the code.

### 7. Using Jupyter Notebook as a Calculator
1. **Basic Calculations**:
    - You can perform calculations in a cell (e.g., `2 + 3` or `4 * 2`).
    - Run the cell to see the output.

### 8. Writing  in Jupyter Notebook
1. **Change Cell Type to **:
    - Select a cell and change the type from `Code` to ``.
2. **Writing Text**:
    - Write  text, such as headings (e.g., `# First Notebook`).
    - Press `Shift + Enter` to render the .

### 9. Download and Share the Notebook
1. **Download as PDF**:
    - Go to `File` -> `Download as` -> `PDF` to save and share your notebook.

### Important Note
- **Keep the Console Running**:
    - If you close the terminal/PowerShell where you executed the Jupyter Notebook command, you will not be able to use Jupyter Notebook in your browser. Keep it running in the background.

## Conclusion
You have successfully installed and set up Jupyter Notebook on your system. Enjoy coding and creating your notebooks!

---

# Day 1: Python Fundamentals

## Keywords and Identifiers

### Python Keywords

**Keywords** are reserved words in Python that have special meanings and cannot be used as variable names, function names, or any other identifiers.

#### Common Python Keywords:

```python
# Here are some important Python keywords:
# and, or, not, if, elif, else, while, for, break, continue
# True, False, None, in, is, def, class, return, import, from
# try, except, finally, raise, with, as, lambda, pass, yield
```

#### Checking All Keywords:

```python
import keyword

# Get all Python keywords
print(keyword.kwlist)
# Output: ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 
#          'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', ...]

# Check if a word is a keyword
print(keyword.iskeyword('for'))    # Output: True
print(keyword.iskeyword('hello'))  # Output: False
```

#### Examples of Keywords in Use:

```python
# Using 'if', 'elif', 'else' keywords
age = 18
if age < 13:
    print("Child")
elif age < 20:
    print("Teenager")
else:
    print("Adult")

# Using 'and', 'or', 'not' keywords
x = 10
y = 20
print(x > 5 and y < 30)  # Output: True
print(x > 15 or y < 30)  # Output: True
print(not (x > 15))      # Output: True

# Using 'True', 'False', 'None' keywords
is_active = True
is_deleted = False
result = None
```

### Python Identifiers

**Identifiers** are names given to variables, functions, classes, modules, or other objects in Python.

#### Rules for Identifiers:

1. **Must start with a letter (a-z, A-Z) or underscore (_)**
2. **Can contain letters, digits (0-9), and underscores**
3. **Cannot start with a digit**
4. **Cannot be a Python keyword**
5. **Case-sensitive** (age, Age, and AGE are different)
6. **No special characters** like !, @, #, $, %, etc.

#### Valid and Invalid Identifiers:

```python
# Valid identifiers
name = "John"
_age = 25
student_1 = "Alice"
myVar = 100
CONSTANT_VALUE = 3.14

# Invalid identifiers (these will cause errors)
# 1student = "Bob"        # Cannot start with a digit
# my-var = 50             # Hyphen not allowed
# for = 10                # 'for' is a keyword
# my var = 20             # Spaces not allowed
# @username = "test"      # Special characters not allowed
```

#### Naming Conventions (PEP 8):

```python
# Variables and functions: lowercase with underscores
user_name = "Alice"
total_count = 100

def calculate_average(numbers):
    return sum(numbers) / len(numbers)

# Constants: UPPERCASE with underscores
MAX_SIZE = 100
PI = 3.14159

# Classes: PascalCase (CapWords)
class StudentRecord:
    pass

class DataProcessor:
    pass
```

---

## Comments in Python

**Comments** are used to explain code and make it more readable. Python ignores comments during execution.

### Single-Line Comments

Use the `#` symbol for single-line comments:

```python
# This is a single-line comment
print("Hello, World!")  # This comment is at the end of a line

# Calculate the area of a rectangle
length = 10  # in meters
width = 5    # in meters
area = length * width
print(f"Area: {area} square meters")
```

### Multi-Line Comments

Python doesn't have a specific multi-line comment syntax, but you can use:

**Method 1: Multiple single-line comments**
```python
# This is a multi-line comment
# spanning multiple lines
# to explain complex logic
x = 10
y = 20
```

**Method 2: Multi-line strings (docstrings)**
```python
"""
This is a multi-line comment
using triple quotes.
It can span multiple lines.
"""

'''
You can also use single quotes
for multi-line comments.
'''

def greet(name):
    """
    This is a docstring.
    It documents what the function does.
    
    Parameters:
        name (str): The name to greet
    
    Returns:
        str: A greeting message
    """
    return f"Hello, {name}!"
```

### Best Practices for Comments:

```python
# Good comments explain WHY, not WHAT
# Bad: Increment x by 1
x = x + 1

# Good: Adjust for zero-based indexing
x = x + 1

# Use comments to explain complex logic
def calculate_discount(price, customer_type):
    # Premium customers get 20% discount
    # Regular customers get 10% discount
    if customer_type == "premium":
        return price * 0.8
    else:
        return price * 0.9
```

---

## Indentation in Python

**Indentation** refers to the spaces at the beginning of a code line. Unlike other programming languages that use braces `{}`, Python uses indentation to define code blocks.

### Why Indentation Matters:

```python
# Correct indentation
if 5 > 2:
    print("Five is greater than two!")  # This is indented
    print("This is also part of the if block")

# Incorrect indentation (will cause IndentationError)
# if 5 > 2:
# print("Five is greater than two!")  # Error: expected an indented block
```

### Standard Indentation:

Python recommends using **4 spaces** per indentation level (PEP 8 standard).

```python
# Using 4 spaces for indentation
def calculate_total(items):
    total = 0
    for item in items:
        if item > 0:
            total += item
    return total

# Nested indentation
for i in range(3):
    print(f"Outer loop: {i}")
    for j in range(2):
        print(f"  Inner loop: {j}")
        if j == 1:
            print("    Condition met!")
```

### Indentation in Different Structures:

```python
# If-elif-else
score = 85
if score >= 90:
    grade = 'A'
    print("Excellent!")
elif score >= 80:
    grade = 'B'
    print("Good job!")
else:
    grade = 'C'
    print("Keep trying!")

# For loop
fruits = ['apple', 'banana', 'cherry']
for fruit in fruits:
    print(f"I like {fruit}")
    if fruit == 'banana':
        print("  Banana is my favorite!")

# While loop
count = 0
while count < 3:
    print(f"Count: {count}")
    count += 1

# Function definition
def greet_user(name, age):
    message = f"Hello, {name}!"
    if age >= 18:
        message += " You are an adult."
    else:
        message += " You are a minor."
    return message
```

### Common Indentation Errors:

```python
# IndentationError: expected an indented block
# def my_function():
# print("Hello")  # Error: needs indentation

# IndentationError: unexpected indent
# x = 5
#     y = 10  # Error: unexpected indentation

# Mixing tabs and spaces (avoid this!)
# Use either tabs OR spaces, not both
```

---

## Python Statements

A **statement** is an instruction that the Python interpreter can execute. Python has different types of statements.

### Types of Statements:

#### 1. Simple Statements (Single Line)

```python
# Assignment statements
x = 10
name = "Alice"
is_valid = True

# Expression statements
5 + 3
print("Hello")
len([1, 2, 3])

# Import statements
import math
from datetime import datetime

# Pass statement (does nothing, placeholder)
def empty_function():
    pass  # TODO: Implement this later

# Delete statement
x = 10
del x  # Deletes the variable x

# Return statement
def get_sum(a, b):
    return a + b

# Break and continue (in loops)
for i in range(10):
    if i == 5:
        break  # Exit the loop
    if i % 2 == 0:
        continue  # Skip to next iteration
    print(i)
```

#### 2. Compound Statements (Multiple Lines)

Compound statements contain groups of other statements and affect their execution.

**If Statement:**
```python
temperature = 25

if temperature > 30:
    print("It's hot!")
    print("Stay hydrated!")
elif temperature > 20:
    print("It's pleasant!")
    print("Enjoy the weather!")
else:
    print("It's cold!")
    print("Wear warm clothes!")
```

**For Loop Statement:**
```python
# Iterate over a list
fruits = ['apple', 'banana', 'cherry']
for fruit in fruits:
    print(f"I like {fruit}")

# Iterate over a range
for i in range(5):
    print(f"Number: {i}")

# Iterate over a dictionary
student = {'name': 'Alice', 'age': 20, 'grade': 'A'}
for key, value in student.items():
    print(f"{key}: {value}")
```

**While Loop Statement:**
```python
# Basic while loop
count = 0
while count < 5:
    print(f"Count: {count}")
    count += 1

# While loop with condition
password = ""
while password != "secret":
    password = input("Enter password: ")
print("Access granted!")
```

**Function Definition Statement:**
```python
def calculate_area(length, width):
    """Calculate the area of a rectangle."""
    area = length * width
    return area

result = calculate_area(10, 5)
print(f"Area: {result}")
```

**Class Definition Statement:**
```python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def display_info(self):
        print(f"Name: {self.name}, Age: {self.age}")

student1 = Student("Alice", 20)
student1.display_info()
```

**Try-Except Statement:**
```python
try:
    number = int(input("Enter a number: "))
    result = 100 / number
    print(f"Result: {result}")
except ValueError:
    print("Invalid input! Please enter a number.")
except ZeroDivisionError:
    print("Cannot divide by zero!")
except Exception as e:
    print(f"An error occurred: {e}")
finally:
    print("Execution completed.")
```

**With Statement:**
```python
# File handling with automatic cleanup
with open('example.txt', 'w') as file:
    file.write("Hello, World!")
# File is automatically closed after the block
```

### Multiple Statements on One Line:

```python
# Using semicolon (not recommended, reduces readability)
x = 5; y = 10; z = x + y

# Better approach: separate lines
x = 5
y = 10
z = x + y
```

### Line Continuation:

```python
# Using backslash for long lines
total = 1 + 2 + 3 + 4 + 5 + \
        6 + 7 + 8 + 9 + 10

# Implicit line continuation (inside parentheses, brackets, braces)
fruits = ['apple', 'banana', 'cherry',
          'date', 'elderberry', 'fig']

result = (1 + 2 + 3 +
          4 + 5 + 6 +
          7 + 8 + 9)

# Function call with multiple arguments
print("Hello",
      "World",
      "from",
      "Python")
```

---

# Basics of Python

## Python Identifiers and Literals

Hello everybody. Welcome to this module. In this module, we will cover the following topics:
- Python Identifiers
- Python Literals

We will also discuss expressions and operators later in this module. Let's dive into the topics.

### Identifiers

Identifiers are names given to entities like functions, variables, classes, etc. in Python. They help in identifying and recognizing these entities. Here are some important rules and guidelines for creating identifiers in Python:
1. **Identifiers cannot start with a number.**
2. **Special characters are not allowed in identifiers.**
3. **Reserved words cannot be used as identifiers.**
4. **Identifiers are case-sensitive.**

#### Practical Example

```python
# Example of an identifier
greet = "Hello Python"
print(greet)  # Output: Hello Python 
```
In the above code, greet is an identifier, and "Hello Python" is a literal value assigned to the variable greet.

### Literals

Literals represent raw data assigned to variables or constants. There are different types of literals in Python:

### Numeric Literals:

Integer: Whole numbers.
Float: Numbers with decimal points.

```python
a = 10  # Integer literal
print(type(a))  # Output: <class 'int'>

b = 5.2  # Float literal
print(type(b))  # Output: <class 'float'>
```

### String Literals:

Sequence of characters enclosed in single or double quotes.

```python
greeting = "Hello Python"
print(type(greeting))  # Output: <class 'str'>

greeting_single = 'Hello Python'
print(type(greeting_single))  # Output: <class 'str'>
```

### Boolean Literals:

Represented by True and False.

```python
is_active = True
print(type(is_active))  # Output: <class 'bool'>

is_inactive = False
print(type(is_inactive))  # Output: <class 'bool'>
```
---

# Expressions and Operators in Python

### Introduction

In this module, we will cover the following topics:
- Expressions
- Operators

We will use Jupyter Notebook to demonstrate these concepts practically.

### Expressions

An expression is a combination of operators and operands that work together to produce a computed value. For example:

```python
6 + 6  # Output: 12
```

In this example, 6 and 6 are operands, and + is an operator. The expression evaluates to a single output, which is 12.

---
## Types of Operators

In Python, there are three main types of operators:

#### Arithmetic Operators
#### Comparison Operators
#### Logical Operators

We will explore each of these in detail.

### Arithmetic Operators
Arithmetic operators perform mathematical operations such as addition, subtraction, multiplication, etc. Here are the different types of arithmetic operators:

#### Addition
```python
a = 10
b = 4
print(a + b)  # Output: 14
```
#### Subtraction
```python
print(a - b)  # Output: 6
```
#### Multiplication

```python
print(a * b)  # Output: 40
```

#### Division

```python
print(a / b)  # Output: 2.5
```
#### Modulo
The modulo operator returns the remainder after division.

```python
print(a % b)  # Output: 2
```
#### Floor Division
The floor division operator returns the division result adjusted to the left in the number line.

```python
print(a // b)  # Output: 2
print((-a) // b)  # Output: -3
```
#### Exponent
The exponent operator raises the left operand to the power of the right operand.

```python
print(a ** b)  
```
---
# Comparison Operators in Python

## Introduction

Hello everybody. In this lecture, we will understand and explore how comparison operators work in Python using Jupyter Notebook.

## Comparison Operators

Comparison operators compare the values of two operands and return a Boolean result (True or False). Below are the types of comparison operators in Python:

### Equal to (`==`)

```python
a = 10
b = 4
c = 4

print(a == b)  # Output: False
print(b == c)  # Output: True
```

Not Equal to (!=)
```python
print(b != c)  # Output: False
```
Greater than (>)
```python
print(b > c)  # Output: False
print(a > c)  # Output: True
```
Less than (<)
```python
print(b < c)  # Output: False
print(a < c)  # Output: False
```
Greater than or Equal to (>=)
```python
print(b >= c)  # Output: True
```
Less than or Equal to (<=)
```python
print(b <= c)  # Output: True
```
#### Summary of Comparison Operators
Comparison operators evaluate conditions and return Boolean values. They help in decision-making processes by comparing the values of variables.

#### Logical Operators in Python
Introduction
Hello everybody. In this lecture, we will understand and explore logical operators that exist in Python using Jupyter Notebook.

#### Logical Operators
Logical operators are used in decision-making and work on Boolean operands. There are three types of logical operators:

#### Logical AND (and)
The and operator returns True if both operands are True; otherwise, it returns False.

```python
print(True and True)   # Output: True
print(True and False)  # Output: False
```
#### Logical OR (or)
The or operator returns True if at least one operand is True; otherwise, it returns False.

```python
print(True or False)   # Output: True
print(False or False)  # Output: False
```
#### Logical NOT (not)
The not operator inverts the Boolean value.

```python
print(not True)   # Output: False
print(not False)  # Output: True
```
Using Logical Operators with Expressions
Logical operators can also be used with expressions.

```python
a = 10
b = 4
c = 4
```
#### Logical AND
```python
print((b >= c) and (a <= c))  # Output: False
```
#### Logical OR
```python
print((b >= c) or (a <= c))  # Output: True
```

---

# Day 2: Control Flow - Loops

## While Loop

The **while loop** executes a block of code repeatedly as long as a specified condition is `True`.

### Basic While Loop Syntax:

```python
while condition:
    # Code block to execute
    # This runs as long as condition is True
```

### Simple While Loop Examples:

```python
# Example 1: Count from 0 to 4
count = 0
while count < 5:
    print(f"Count: {count}")
    count += 1

# Output:
# Count: 0
# Count: 1
# Count: 2
# Count: 3
# Count: 4

# Example 2: Sum of numbers
total = 0
number = 1
while number <= 10:
    total += number
    number += 1
print(f"Sum of 1 to 10: {total}")  # Output: Sum of 1 to 10: 55
```

### While Loop with User Input:

```python
# Password validation
password = ""
while password != "python123":
    password = input("Enter the password: ")
    if password != "python123":
        print("Incorrect password. Try again!")
print("Access granted!")

# Guess the number game
secret_number = 7
guess = 0
attempts = 0

while guess != secret_number:
    guess = int(input("Guess the number (1-10): "))
    attempts += 1
    if guess < secret_number:
        print("Too low!")
    elif guess > secret_number:
        print("Too high!")
    else:
        print(f"Correct! You guessed it in {attempts} attempts!")
```

### While Loop with Multiple Conditions:

```python
# ATM withdrawal simulation
balance = 1000
pin = "1234"
entered_pin = ""
attempts = 0
max_attempts = 3

while entered_pin != pin and attempts < max_attempts:
    entered_pin = input("Enter your PIN: ")
    attempts += 1
    if entered_pin != pin:
        remaining = max_attempts - attempts
        if remaining > 0:
            print(f"Incorrect PIN. {remaining} attempts remaining.")
        else:
            print("Card blocked due to too many incorrect attempts!")

if entered_pin == pin:
    print(f"Welcome! Your balance is ${balance}")
```

### Infinite Loops (Be Careful!):

```python
# Infinite loop example (use Ctrl+C to stop)
# while True:
#     print("This will run forever!")

# Controlled infinite loop with break
while True:
    user_input = input("Enter 'quit' to exit: ")
    if user_input.lower() == 'quit':
        print("Goodbye!")
        break
    print(f"You entered: {user_input}")
```

### While Loop with Else Clause:

The `else` clause executes when the loop completes normally (not interrupted by `break`).

```python
# Example: Finding a number in a list
numbers = [1, 3, 5, 7, 9]
target = 6
index = 0

while index < len(numbers):
    if numbers[index] == target:
        print(f"Found {target} at index {index}")
        break
    index += 1
else:
    print(f"{target} not found in the list")

# Output: 6 not found in the list
```

---

## For Loop

The **for loop** is used to iterate over a sequence (list, tuple, string, range, etc.).

### Basic For Loop Syntax:

```python
for variable in sequence:
    # Code block to execute
    # Runs once for each item in the sequence
```

### For Loop with Lists:

```python
# Iterate over a list of fruits
fruits = ['apple', 'banana', 'cherry', 'date']
for fruit in fruits:
    print(f"I like {fruit}")

# Output:
# I like apple
# I like banana
# I like cherry
# I like date

# Iterate with index using enumerate()
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")

# Output:
# 0: apple
# 1: banana
# 2: cherry
# 3: date

# Start enumeration from 1
for index, fruit in enumerate(fruits, start=1):
    print(f"{index}. {fruit}")
```

### For Loop with range():

```python
# range(stop) - from 0 to stop-1
for i in range(5):
    print(i, end=' ')  # Output: 0 1 2 3 4

print()  # New line

# range(start, stop) - from start to stop-1
for i in range(2, 8):
    print(i, end=' ')  # Output: 2 3 4 5 6 7

print()  # New line

# range(start, stop, step) - with custom step
for i in range(0, 10, 2):
    print(i, end=' ')  # Output: 0 2 4 6 8

print()  # New line

# Reverse range
for i in range(10, 0, -1):
    print(i, end=' ')  # Output: 10 9 8 7 6 5 4 3 2 1
```

### For Loop with Strings:

```python
# Iterate over characters in a string
message = "Python"
for char in message:
    print(char)

# Output:
# P
# y
# t
# h
# o
# n

# Count vowels in a string
text = "Hello World"
vowels = "aeiouAEIOU"
vowel_count = 0

for char in text:
    if char in vowels:
        vowel_count += 1
print(f"Number of vowels: {vowel_count}")  # Output: Number of vowels: 3
```

### For Loop with Dictionaries:

```python
# Iterate over dictionary keys
student = {'name': 'Alice', 'age': 20, 'grade': 'A', 'city': 'New York'}

for key in student:
    print(f"{key}: {student[key]}")

# Iterate over key-value pairs using items()
for key, value in student.items():
    print(f"{key} = {value}")

# Iterate over values only
for value in student.values():
    print(value)

# Iterate over keys only
for key in student.keys():
    print(key)
```

### Nested For Loops:

```python
# Multiplication table
for i in range(1, 6):
    for j in range(1, 6):
        print(f"{i} x {j} = {i*j:2d}", end="  ")
    print()  # New line after each row

# Pattern printing
for i in range(1, 6):
    for j in range(i):
        print("*", end="")
    print()

# Output:
# *
# **
# ***
# ****
# *****
```

### For Loop with Else Clause:

```python
# Search for a prime number
number = 17
for i in range(2, number):
    if number % i == 0:
        print(f"{number} is not prime (divisible by {i})")
        break
else:
    print(f"{number} is a prime number")

# Output: 17 is a prime number
```

---

## Break Statement

The **break** statement terminates the loop immediately and transfers control to the statement following the loop.

### Break in While Loop:

```python
# Stop when a condition is met
count = 0
while count < 10:
    if count == 5:
        print("Breaking at 5")
        break
    print(count)
    count += 1

# Output:
# 0
# 1
# 2
# 3
# 4
# Breaking at 5

# Search in a list
numbers = [10, 20, 30, 40, 50]
target = 30
index = 0

while index < len(numbers):
    if numbers[index] == target:
        print(f"Found {target} at index {index}")
        break
    index += 1
```

### Break in For Loop:

```python
# Find first even number
numbers = [1, 3, 5, 8, 9, 11]
for num in numbers:
    if num % 2 == 0:
        print(f"First even number: {num}")
        break

# Output: First even number: 8

# Login system with limited attempts
max_attempts = 3
correct_password = "secure123"

for attempt in range(1, max_attempts + 1):
    password = input(f"Attempt {attempt}/{max_attempts} - Enter password: ")
    if password == correct_password:
        print("Login successful!")
        break
    else:
        remaining = max_attempts - attempt
        if remaining > 0:
            print(f"Incorrect! {remaining} attempts remaining.")
else:
    print("Account locked. Too many failed attempts.")
```

### Break in Nested Loops:

```python
# Break only exits the innermost loop
for i in range(3):
    print(f"Outer loop: {i}")
    for j in range(5):
        if j == 2:
            print(f"  Breaking inner loop at j={j}")
            break
        print(f"  Inner loop: {j}")

# To break out of all loops, use a flag
found = False
for i in range(3):
    for j in range(3):
        if i == 1 and j == 1:
            print(f"Found at ({i}, {j})")
            found = True
            break
    if found:
        break
```

---

## Continue Statement

The **continue** statement skips the rest of the current iteration and moves to the next iteration of the loop.

### Continue in While Loop:

```python
# Skip even numbers
count = 0
while count < 10:
    count += 1
    if count % 2 == 0:
        continue  # Skip even numbers
    print(count)

# Output: 1 3 5 7 9

# Process only valid inputs
attempts = 0
while attempts < 5:
    attempts += 1
    user_input = input("Enter a positive number: ")
    
    if not user_input.isdigit():
        print("Invalid input! Please enter a number.")
        continue
    
    number = int(user_input)
    if number <= 0:
        print("Number must be positive!")
        continue
    
    print(f"You entered: {number}")
    print(f"Square: {number ** 2}")
```

### Continue in For Loop:

```python
# Skip specific values
for i in range(1, 11):
    if i == 5:
        continue  # Skip 5
    print(i, end=' ')

# Output: 1 2 3 4 6 7 8 9 10

# Process only certain items
fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry']
for fruit in fruits:
    if len(fruit) < 6:
        continue  # Skip fruits with less than 6 characters
    print(fruit)

# Output:
# banana
# cherry
# elderberry

# Skip negative numbers in calculations
numbers = [10, -5, 20, -3, 15, -8, 25]
total = 0
for num in numbers:
    if num < 0:
        continue  # Skip negative numbers
    total += num
print(f"Sum of positive numbers: {total}")  # Output: Sum of positive numbers: 70
```

### Continue with Else Clause:

```python
# Find all odd numbers
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
odd_numbers = []

for num in numbers:
    if num % 2 == 0:
        continue  # Skip even numbers
    odd_numbers.append(num)
else:
    print(f"Odd numbers: {odd_numbers}")

# Output: Odd numbers: [1, 3, 5, 7, 9]
```

### Practical Example: Data Filtering:

```python
# Filter and process student grades
students = [
    {'name': 'Alice', 'score': 85},
    {'name': 'Bob', 'score': 45},
    {'name': 'Charlie', 'score': 92},
    {'name': 'David', 'score': 35},
    {'name': 'Eve', 'score': 78}
]

print("Students who passed (score >= 50):")
for student in students:
    if student['score'] < 50:
        continue  # Skip students who failed
    print(f"{student['name']}: {student['score']}")

# Output:
# Students who passed (score >= 50):
# Alice: 85
# Charlie: 92
# Eve: 78
```

---

## Combining Break and Continue

You can use both `break` and `continue` in the same loop for complex logic:

```python
# Process numbers with multiple conditions
numbers = [5, 12, -3, 18, 0, 25, -7, 30, 15]

for num in numbers:
    # Skip negative numbers
    if num < 0:
        print(f"Skipping negative number: {num}")
        continue
    
    # Stop if we encounter zero
    if num == 0:
        print("Encountered zero. Stopping.")
        break
    
    # Process only even numbers
    if num % 2 != 0:
        continue
    
    print(f"Processing even number: {num}, Square: {num ** 2}")

# Output:
# Skipping negative number: -3
# Processing even number: 12, Square: 144
# Processing even number: 18, Square: 324
# Encountered zero. Stopping.
```

### Real-World Example: Menu System:

```python
# Simple calculator menu
while True:
    print("\n=== Calculator Menu ===")
    print("1. Add")
    print("2. Subtract")
    print("3. Multiply")
    print("4. Divide")
    print("5. Exit")
    
    choice = input("Enter your choice (1-5): ")
    
    # Exit the program
    if choice == '5':
        print("Thank you for using the calculator!")
        break
    
    # Validate choice
    if choice not in ['1', '2', '3', '4']:
        print("Invalid choice! Please try again.")
        continue
    
    # Get numbers from user
    try:
        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))
    except ValueError:
        print("Invalid input! Please enter numbers only.")
        continue
    
    # Perform calculation
    if choice == '1':
        result = num1 + num2
        print(f"Result: {num1} + {num2} = {result}")
    elif choice == '2':
        result = num1 - num2
        print(f"Result: {num1} - {num2} = {result}")
    elif choice == '3':
        result = num1 * num2
        print(f"Result: {num1} * {num2} = {result}")
    elif choice == '4':
        if num2 == 0:
            print("Error: Cannot divide by zero!")
            continue
        result = num1 / num2
        print(f"Result: {num1} / {num2} = {result}")
```

---

## Revision: Python Basics

### Key Concepts Covered in Days 1-2:

#### 1. **Keywords and Identifiers**
- Reserved words in Python
- Rules for naming variables and functions
- PEP 8 naming conventions

#### 2. **Comments and Documentation**
- Single-line comments with `#`
- Multi-line comments with `'''` or `"""`
- Docstrings for functions and classes

#### 3. **Indentation**
- Python uses indentation to define code blocks
- Standard is 4 spaces per level
- Critical for proper code execution

#### 4. **Data Types**
- Integers, Floats, Strings, Booleans
- Type conversion functions
- Dynamic typing

#### 5. **Operators**
- Arithmetic: `+`, `-`, `*`, `/`, `//`, `%`, `**`
- Comparison: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Logical: `and`, `or`, `not`

#### 6. **Control Flow**
- `if`, `elif`, `else` statements
- Conditional expressions
- Nested conditions

#### 7. **Loops**
- `while` loop for condition-based iteration
- `for` loop for sequence iteration
- `range()` function for numeric sequences
- `break` to exit loops
- `continue` to skip iterations
- `else` clause with loops

### Practice Exercises:

```python
# Exercise 1: Print all even numbers from 1 to 20
for num in range(2, 21, 2):
    print(num, end=' ')
print()

# Exercise 2: Calculate factorial using while loop
n = 5
factorial = 1
i = 1
while i <= n:
    factorial *= i
    i += 1
print(f"Factorial of {n} is {factorial}")

# Exercise 3: Find sum of digits
number = 12345
sum_digits = 0
while number > 0:
    digit = number % 10
    sum_digits += digit
    number //= 10
print(f"Sum of digits: {sum_digits}")

# Exercise 4: Print multiplication table
num = 7
for i in range(1, 11):
    print(f"{num} x {i} = {num * i}")
```

---
````
---
# Python Packages and Data Structures

## Introduction

Hello everybody, and welcome to this class. In this module, we will cover the following topics:
- Python Packages
- Python Data Structures (Lists, Tuples, Sets)

We will start by discussing Python packages and then move on to various data structures in Python.

## Python Packages

### What are Packages?

We, as humans, like to organize everything, whether it's our clothes, books, files, or code. In Python, we organize code using modules and packages. Hereâ€™s a breakdown:
- **Modules:** These are individual Python files containing variables, functions, and classes that can be imported and reused in other Python files.
- **Packages:** A group of related modules that serve a common functionality.

### Importance of Packages

Packages enable better organization and code reusability. For instance, in a banking application, all modules related to savings account operations can be grouped into a single package.

### Creating and Using Packages

- **Developers can create their own packages.**
- **Third-party packages** built by others can be used.
- **Python Standard Library**: Comes with numerous packages pre-installed for developersâ€™ use.

### Example

If you're building a banking application, you might create a package like:

banking/ init.py savings.pyloans.pyaccounts.py

### Summary
Python Packages: Groups of related modules serving common functionalities, which help in organizing code efficiently.

# Using Packages in Python

## Introduction

In this module, we will cover how to use and install packages in Python. We will perform a demo to understand the process of using packages that may or may not be installed on your system.

## Demo: Using Packages in Python

### Step 1: Search for the Package

1. Open your web browser and go to Google.
2. Search for "pypi python" to find the Python Package Index (PyPI) website.
3. Click on the first link, which should be `pypi.org`.

### Step 2: Search for a Specific Package

1. On the PyPI website, use the search box to search for the package "camelcase".
2. Select the first result, "camelcase 0.2".

### Step 3: Understanding the Package

The "camelcase" package is used to convert a string to camelcase. The project home page provides sample code that demonstrates its basic usage.

### Step 4: Installing the Package

1. Open your coding editor, such as Jupyter Notebook.
2. To use the package, you first need to install it. The installation command provided on the PyPI project page is `pip install camelcase`.

```bash
pip install camelcase
```
---
# Using Packages in Python

## Introduction

In this module, we will cover how to use and install packages in Python. We will perform a demo to understand the process of using packages that may or may not be installed on your system.

## Demo: Using Packages in Python

### Step 1: Search for the Package

1. Open your web browser and go to Google.
2. Search for "pypi python" to find the Python Package Index (PyPI) website.
3. Click on the first link, which should be `pypi.org`.

### Step 2: Search for a Specific Package

1. On the PyPI website, use the search box to search for the package "camelcase".
2. Select the first result, "camelcase 0.2".

### Step 3: Understanding the Package

The "camelcase" package is used to convert a string to camelcase. The project home page provides sample code that demonstrates its basic usage.

### Step 4: Installing the Package

1. Open your coding editor, such as Jupyter Notebook.
2. To use the package, you first need to install it. The installation command provided on the PyPI project page is `pip install camelcase`.

```bash
pip install camelcase
```

### Step 5: Running the Code
1. In Jupyter Notebook, open a terminal by clicking on "New" and then "Terminal".

2. Run the install command:

```bash
pip install camelcase
```

3. After successful installation, you should see a success message indicating the package version.

### Step 6: Using the Package in Your Code
Switch back to your Jupyter Notebook and use the following code to utilize the camelcase package:


```python
import camelcase

# Create an instance of the CamelCase class
c = camelcase.CamelCase()

# Create a string
s = "how are you?"

# Convert the string to camelcase
print(c.hump(s))  # Output: How Are You?
```
### Step 7: Re-run the Code
After installing the package, re-run the code. You should now see the camelcased output.

Additional Information
Data Science Packages
There are many packages available for data science. These can be installed individually using pip or through the Anaconda distribution.

#### Anaconda Distribution
Anaconda is a Python distribution that comes pre-installed with many packages needed for data science, such as:

NumPy

SciPy

Jupyter Notebook

pandas

#### Package Managers
pip: The standard Python package manager used for installing and managing packages.

Conda: Anaconda's package manager used for managing packages in the Anaconda distribution.

#### Summary
To summarize, in this module we have covered:

Searching and Installing Packages: Using the PyPI website and pip command.

Using Installed Packages: Demonstrating the camelcase package in a Python code.

Data Science Packages and Anaconda: An overview of using Anaconda for pre-installed data science packages and using Conda as a package manager.

---

# Python Data Structures

Hello everybody. Welcome to this class. Let us start discussing Python data structures. Today, we live in an information age wherein there is a lot of data around us. It is important that we should be able to organize, process, and work with data in the most efficient way. This is where data structures come into the picture. Data structures allow us to organize, process, and work with the data. They make it easy for us to work with data in an easy and efficient manner. 

There are some built-in data structures in Python:
- Lists
- Tuples
- Sets
- Dictionary 

## Lists
## What Are Lists in Python

Welcome to this class on lists. We are going to do a demo in this class wherein we are going to discuss how to create lists. We will cover how to use them in your program and access individual elements as well. We will discuss the different characteristics of lists, enabling you to make better decisions about when to use the list data structure.

### Creating Lists

Here are some examples of creating lists in Python:

```python
# Creating a list of names
my_list = ['Alice', 'Bob', 'Charlie']
print(my_list)  # Output: ['Alice', 'Bob', 'Charlie']
print(type(my_list))  # Output: <class 'list'>

# Creating a list of numbers
number_list = [1, 2, 3, 4, 5]
print(number_list)  # Output: [1, 2, 3, 4, 5]
print(type(number_list))  # Output: <class 'list'>

# Creating a mixed data type list
mixed_list = [1, 'John', 2.5]
print(mixed_list)  # Output: [1, 'John', 2.5]
print(type(mixed_list))  # Output: <class 'list'>

# Creating a nested list
nested_list = [1, 2, 3, ['a', 'b', 'c']]
print(nested_list)  # Output: [1, 2, 3, ['a', 'b', 'c']]
print(type(nested_list))  # Output: <class 'list'>

# Creating an empty list
empty_list = []
print(empty_list)  # Output: []
print(type(empty_list))  # Output: <class 'list'>
```

#### Accessing Elements in Lists
Lists are represented in memory and can be accessed using indexing. Python supports positive and negative indexing.
Positive indexing starts at 0
Negative indexing starts at -1

```python
# Positive indexing
names = ['John', 'Jane', 'Doe']
print(names[0])  # Output: John

# Negative indexing
print(names[-1])  # Output: Doe

# Accessing elements in a nested list
nested_list = [1, 2, 3, ['a', 'b', 'c']]
print(nested_list[3][1])  # Output: b
```
Mutable: Lists can be modified.

```python
my_list = ['Alice', 'Bob', 'Charlie']
my_list[0] = 'Jonny'
print(my_list)  # Output: ['Jonny', 'Bob', 'Charlie']

# Appending elements
my_list.append('Rob')
print(my_list)  # Output: ['Jonny', 'Bob', 'Charlie', 'Rob']
Ordered: Lists maintain the order of elements.
```
```python
print(my_list)  # Output: ['Jonny', 'Bob', 'Charlie', 'Rob']
Allows Duplicates: Lists can have duplicate elements.
```
```python
duplicate_list = ['Andy', 'Andy']
print(duplicate_list)  # Output: ['Andy', 'Andy']
```

#### Real-World Example of Lists
You can use lists to store items in an online shopping cart. Lists are a good choice for this because:
They are mutable, allowing items to be added or removed as needed.
They provide an ordered collection of items, preserving the order in which items were added to the cart. This is useful for displaying items to the customer and keeping track of the sequence of events leading up to the purchase.

```python
shopping_cart = ['apple', 'banana', 'cherry']
shopping_cart.append('date')
print(shopping_cart)  # Output: ['apple', 'banana', 'cherry', 'date']
```

## Tuples
### What Are Tuples
Hello everybody. Welcome to this class. In this class, we are going to do a handsâ€‘on demo wherein we are going to discuss all about tuples. We are going to cover how you can create your own set of tuples, how you can use them in your programs, and we will even discuss the characteristics of tuples. Understanding the characteristics will enable you to make better decisions as to how and when to use this data structure in your Python programs. So let's get started.

### Creating Tuples
Tuples are data structures that allow you to store multiple items. Here is how you can create a tuple:

```python
# Creating a tuple with three names of fruits
my_tuple = ('apple', 'banana', 'cherry')
print(my_tuple)  # Output: ('apple', 'banana', 'cherry')
print(type(my_tuple))  # Output: <class 'tuple'>
```

Single Element Tuple
To create a tuple with a single element, you need to include a comma after the element:
```python
# Incorrect way (creates a string)
single_element_tuple = ('apple')
print(type(single_element_tuple))  # Output: <class 'str'>
```
```python
# Correct way (creates a tuple)
single_element_tuple = ('apple',)
print(type(single_element_tuple))  # Output: <class 'tuple'>
```
Mixed Type Tuple
You can create tuples with mixed data types:

```python
mixed_tuple = ('apple', 'banana', 'cherry', 10, 11.5)
print(mixed_tuple)  # Output: ('apple', 'banana', 'cherry', 10, 11.5)
```

Empty Tuple
Creating an empty tuple:

```python
empty_tuple = ()
print(empty_tuple)  # Output: ()
print(type(empty_tuple))  # Output: <class 'tuple'>
```

#### Accessing Elements in Tuples
Tuples support indexing similar to lists:

```python
# Accessing elements using positive index
print(my_tuple[0])  # Output: apple
```

```python
# Accessing elements using negative index
print(my_tuple[-1])  # Output: cherry
```
```python
# Checking existence of an element
print('apple' in my_tuple)  # Output: True
print('watermelon' in my_tuple)  # Output: False
```


Tuple Packing and Unpacking
Tuple Packing
Combining multiple values into a single tuple:

```python
name = 'John'
age = 25
city = 'New York'
packed_tuple = (name, age, city)
print(packed_tuple)  # Output: ('John', 25, 'New York')
```

Tuple Unpacking
Extracting individual values from a tuple:

```python
person = ('John', 25, 'New York')
name, age, city = person
print(name)  # Output: John
print(age)  # Output: 25
print(city)  # Output: New York
```

Using Tuples in Functions
Tuples can be used to return multiple values from a function:

```python
def get_user_info():
    return ('John Doe', 30, 'Los Angeles')

name, age, city = get_user_info()
print(name)  # Output: John Doe
print(age)  # Output: 30
print(city)  # Output: Los Angeles
```

#### Characteristics of Tuples
Immutable: Tuples cannot be modified after creation. 

```python
my_tuple = ('apple', 'banana', 'cherry')
try:
    my_tuple[0] = 'orange'
except TypeError as e:
    print(e)  # Output: 'tuple' object does not support item assignment
```
Ordered: Tuples maintain the order of elements.

```python
print(my_tuple)  # Output: ('apple', 'banana', 'cherry')
```

Allows Duplicates: Tuples can have duplicate elements.

```python
duplicate_tuple = ('Andy', 'Andy')
print(duplicate_tuple)  # Output: ('Andy', 'Andy')
```

Real-World Use Cases of Tuples
Since tuples are ordered and immutable, 
they are often used to store data that needs to be grouped together and has an unchanging structure. A common example is storing geographic coordinates for a location:


```python
# Latitude and Longitude of a location
coordinates = (40.7128, -74.0060)
print(coordinates)  # Output: (40.7128, -74.0060)
```

Tuples are a good choice for this kind of data because they avoid accidental changes that could cause errors in an application that relies on them.

## Sets
## What Are Sets

Hello everybody. Welcome to this class. In this class, we are going to cover sets, wherein we are going to do a hands-on demo, and we are going to understand this data structure completely. We are going to discuss how you can create your own set, how you can use them in your Python program, and we will even discuss the characteristics of sets. So let's get started.

## Creating Sets

A set is a data structure that allows you to store multiple items with unique characteristics compared to lists and tuples.

### Creating a Set

Here's how you can create a set:

```python
# Creating a set of email IDs
my_set = {'john@example.com', 'jane@example.com', 'doe@example.com'}
print(my_set)  # Output: {'john@example.com', 'jane@example.com', 'doe@example.com'}
print(type(my_set))  # Output: <class 'set'>
```

Set with Numbers
You can create a set with a list of numbers:

```python
number_set = {1, 2, 13, 4, 5.0, 6.7}
print(number_set)  # Output: {1, 2, 4, 5.0, 6.7, 13}
print(type(number_set))  # Output: <class 'set'>
```

Set with Mixed Types
You can create a set with mixed data types:

```python
mixed_set = {1, 1.5, 'Hello'}
print(mixed_set)  # Output: {1, 1.5, 'Hello'}
print(type(mixed_set))  # Output: <class 'set'>
```

Creating an Empty Set
To create an empty set, you must use the set() function:

```python
empty_set = set()
print(empty_set)  # Output: set()
print(type(empty_set))  # Output: <class 'set'>
```
#### Accessing Elements in Sets
Sets do not support indexing. If you try to use indexing with a set, you will get an error.

Iterating Through a Set
You can iterate through a set using a for loop:

```python
for email in my_set:
    print(email)
# Output:
# john@example.com
# jane@example.com
# doe@example.com
```
#### Using the in Operator
You can use the in and not in operators to check if an element exists in a set:

```python
# Check if element exists in set
print('john@example.com' in my_set)  # Output: True
print('john22@example.com' in my_set)  # Output: False
```
```python
# Check if element does not exist in set
print('john@example.com' not in my_set)  # Output: False
print('john22@example.com' not in my_set)  # Output: True
```
#### Characteristics of Sets
Immutable: Once a set is created, you cannot modify its elements.

```python
my_set = {'apple', 'banana', 'cherry'}
try:
    my_set[0] = 'orange'
except TypeError as e:
    print(e)  # Output: 'set' object does not support item assignment
Unordered: Sets do not maintain the order of elements.
```

```python
print(my_set)  # Output: {'banana', 'cherry', 'apple'}
No Duplicates: Sets do not allow duplicate elements.
```
```python
my_set = {'john@example.com', 'jane@example.com', 'john@example.com'}
print(my_set)  # Output: {'john@example.com', 'jane@example.com'}
```

#### Real-World Use Cases of Sets
Since sets are unordered and do not allow duplicate items, you can use them to store and maintain unique email addresses in your application. Sets are often used to store lists of unique items where the order is not important. For example, in a mailing list, ensuring there are no duplicate addresses is crucial to avoid sending multiple emails to the same recipient, which could be seen as spam and damage the sender's reputation.

Example: Mailing List
```python
email_list = ['john@example.com', 'jane@example.com', 'doe@example.com']
email_set = set(email_list)
print(email_set)  # Output: {'john@example.com', 'jane@example.com', 'doe@example.com'}
```

Certainly! Here is a **Python Dictionary** section for your README, following the same explanatory and hands-on style as your Sets section:

---

## Dictionaries  
## What Are Dictionaries

Hello everybody. Welcome to this class. In this class, we are going to cover dictionaries, a powerful and versatile data structure in Python. Weâ€™ll explore how to create dictionaries, how to use them in your Python programs, and discuss their unique characteristics. By the end, youâ€™ll know how to store and retrieve data efficiently using dictionaries. So letâ€™s get started!

## Creating Dictionaries

A **dictionary** allows you to store data in key-value pairs. Each key must be unique, and each key is associated with a value.

### Creating a Dictionary

Hereâ€™s how you can create a dictionary:

```python
# Creating a dictionary of car details
car = {'brand': 'Ford', 'model': 'Mustang', 'year': 1964}
print(car)         # Output: {'brand': 'Ford', 'model': 'Mustang', 'year': 1964}
print(type(car))   # Output: 
```

#### Dictionary with Mixed Types

You can store mixed data types as values:

```python
person = {'name': 'Alice', 'age': 30, 'is_student': False, 'skills': ['Python', 'Data Analysis']}
print(person)
# Output: {'name': 'Alice', 'age': 30, 'is_student': False, 'skills': ['Python', 'Data Analysis']}
```

#### Creating an Empty Dictionary

To create an empty dictionary:

```python
empty_dict = {}
print(empty_dict)       # Output: {}
print(type(empty_dict)) # Output: 
```

Or using the `dict()` constructor:

```python
another_dict = dict()
print(another_dict)     # Output: {}
```

## Accessing Elements in Dictionaries

Access values by their keys:

```python
print(car['brand'])     # Output: Ford
print(person['skills']) # Output: ['Python', 'Data Analysis']
```

Or use the `get()` method:

```python
print(car.get('model')) # Output: Mustang
```

## Adding and Updating Items

Add a new key-value pair or update an existing one:

```python
car['color'] = 'red'    # Add new key-value pair
car['year'] = 2020      # Update existing value
print(car)              # Output: {'brand': 'Ford', 'model': 'Mustang', 'year': 2020, 'color': 'red'}
```

Or use the `update()` method:

```python
car.update({'engine': 'V8'})
print(car)              # Output: {'brand': 'Ford', 'model': 'Mustang', 'year': 2020, 'color': 'red', 'engine': 'V8'}
```

## Removing Items

You can remove items in several ways:

```python
car.pop('model')        # Removes the key 'model'
car.popitem()           # Removes the last inserted key-value pair
del car['brand']        # Removes the key 'brand'
car.clear()             # Empties the dictionary
```

## Iterating Through a Dictionary

You can loop through keys, values, or both:

```python
for key in person:
    print(key, person[key])

for value in person.values():
    print(value)

for key, value in person.items():
    print(f"{key}: {value}")
```

## Checking for Keys

Check if a key exists in the dictionary:

```python
if 'age' in person:
    print("Yes, 'age' is a key in the person dictionary.")
```

## Characteristics of Dictionaries

- **Mutable:** You can add, update, or remove items.
- **Unordered (before Python 3.7):** The order of items is not guaranteed.  
  **Ordered (Python 3.7+):** Items maintain insertion order.
- **No Duplicate Keys:** Each key must be unique; assigning a value to an existing key overwrites the previous value.
- **Keys Must Be Immutable:** Keys can be strings, numbers, or tuples, but not lists or other dictionaries.

## Real-World Use Cases of Dictionaries

Dictionaries are ideal for representing structured data, such as records from a database, configuration settings, or mapping unique IDs to values. For example, you can use a dictionary to store and quickly access user profiles by username:

```python
users = {
    'alice': {'email': 'alice@example.com', 'age': 30},
    'bob': {'email': 'bob@example.com', 'age': 25}
}
print(users['alice']['email'])  # Output: alice@example.com
```

Dictionaries are also commonly used for counting occurrences, grouping data, and implementing caches.

---

**Summary:**  
Dictionaries are a core data structure in Python, allowing you to associate unique keys with values for fast and flexible data access.
Mastering dictionaries will help you write efficient and readable Python code for a wide range of data analysis tasks.

---
## Summary
So we have reached the end of the module, and we have covered and learned a lot. Let us summarize our learnings:

Python Packages: Python packages are fundamental to programming, especially for organizing large projects.

Data Structures: We covered lists, tuples, and sets, which are crucial for programming.

Key Points

### Lists:
#### Can be created with mixed data types.
#### Supports nested lists and empty lists.
#### Allows indexing and modifying elements.
#### Ordered and allows duplicates.

### Tuples:
#### Can be created with mixed data types.
#### Allows indexing and checking element existence with in operator.
#### Immutable and ordered.
#### Allows duplicates.

### Sets:
#### Can be created with mixed data types.
#### Allows checking element existence with in operator.
#### Immutable after creation.
#### Unordered and does not allow duplicates.

### Dictionaries:
#### Store data as key-value pairs, with each key mapping to a specific value.
#### Keys must be unique and immutable (e.g., strings, numbers, tuples); values can be of any data type and can be duplicated.
#### Support mixed data types for values, including lists, other dictionaries, and more.
#### Are ordered as of Python 3.7+ (items maintain insertion order); unordered in earlier versions.
#### Changeable (mutable): You can add, update, or remove items after creation.
#### Do not allow duplicate keysâ€”if a key is repeated, the last value assigned to it is retained.
#### Do not support indexing by position; elements are accessed by key.
#### Can be created empty or populated, using curly braces `{}` or the `dict()` constructor.
#### Commonly used for fast lookups, efficient data organization, and mapping relationships.


---

# Day 5: Functions

## Introduction to Functions

A **function** is a reusable block of code that performs a specific task. Functions help organize code, make it more readable, and avoid repetition (DRY - Don't Repeat Yourself principle).

### Why Use Functions?

1. **Code Reusability**: Write once, use many times
2. **Modularity**: Break complex problems into smaller, manageable pieces
3. **Maintainability**: Easier to update and debug
4. **Abstraction**: Hide implementation details
5. **Testing**: Easier to test individual components

### Function Syntax:

```python
def function_name(parameters):
    """Docstring: describes what the function does"""
    # Function body
    # Code to execute
    return value  # Optional
```

### Simple Function Examples:

```python
# Function without parameters
def greet():
    """Print a greeting message"""
    print("Hello, World!")

greet()  # Output: Hello, World!

# Function with parameters
def greet_person(name):
    """Greet a person by name"""
    print(f"Hello, {name}!")

greet_person("Alice")  # Output: Hello, Alice!

# Function with return value
def add_numbers(a, b):
    """Add two numbers and return the result"""
    result = a + b
    return result

sum_result = add_numbers(5, 3)
print(f"Sum: {sum_result}")  # Output: Sum: 8
```

# Day 5-7: Functions, Lambda, File Handling, and Exception Handling

## Day 5: Functions (Continued)

### Recursive Functions

A **recursive function** is a function that calls itself to solve a problem.

```python
# Factorial using recursion
def factorial(n):
    """Calculate factorial using recursion"""
    if n == 0 or n == 1:  # Base case
        return 1
    else:
        return n * factorial(n - 1)  # Recursive case

print(f"5! = {factorial(5)}")  # Output: 5! = 120

# Fibonacci sequence
def fibonacci(n):
    """Return the nth Fibonacci number"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# Print first 10 Fibonacci numbers
for i in range(10):
    print(fibonacci(i), end=' ')
# Output: 0 1 1 2 3 5 8 13 21 34
```

---

## Day 6: Lambda Functions, Modules, Packages, and File Handling

### Lambda Functions

**Lambda functions** are small anonymous functions defined with the `lambda` keyword.

```python
# Basic lambda function
square = lambda x: x ** 2
print(square(5))  # Output: 25

# Lambda with multiple parameters
add = lambda a, b: a + b
print(add(3, 7))  # Output: 10

# Lambda with conditional
max_value = lambda a, b: a if a > b else b
print(max_value(10, 20))  # Output: 20

# Using lambda with map()
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))
print(squared)  # Output: [1, 4, 9, 16, 25]

# Using lambda with filter()
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # Output: [2, 4]

# Using lambda with sorted()
students = [
    {'name': 'Alice', 'grade': 85},
    {'name': 'Bob', 'grade': 92},
    {'name': 'Charlie', 'grade': 78}
]
sorted_students = sorted(students, key=lambda x: x['grade'], reverse=True)
for student in sorted_students:
    print(f"{student['name']}: {student['grade']}")
```

### File Handling

Working with files is essential for data persistence.

#### Reading Files:

```python
# Method 1: Using with statement (recommended)
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
# File is automatically closed

# Read line by line
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())

# Read all lines into a list
with open('example.txt', 'r') as file:
    lines = file.readlines()
    print(lines)

# Read specific number of characters
with open('example.txt', 'r') as file:
    first_10_chars = file.read(10)
    print(first_10_chars)
```

#### Writing Files:

```python
# Write to file (overwrites existing content)
with open('output.txt', 'w') as file:
    file.write("Hello, World!\n")
    file.write("This is a new line.\n")

# Append to file
with open('output.txt', 'a') as file:
    file.write("This line is appended.\n")

# Write multiple lines
lines = ["Line 1\n", "Line 2\n", "Line 3\n"]
with open('output.txt', 'w') as file:
    file.writelines(lines)
```

#### File Modes:

```python
# 'r'  - Read (default)
# 'w'  - Write (overwrites)
# 'a'  - Append
# 'r+' - Read and write
# 'w+' - Write and read (overwrites)
# 'a+' - Append and read
# 'rb' - Read binary
# 'wb' - Write binary
```

#### Working with CSV Files:

```python
import csv

# Write CSV
data = [
    ['Name', 'Age', 'City'],
    ['Alice', 25, 'New York'],
    ['Bob', 30, 'London'],
    ['Charlie', 28, 'Paris']
]

with open('people.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

# Read CSV
with open('people.csv', 'r') as file:
    reader = csv.reader(file)
    for row in reader:
        print(row)

# Using DictReader/DictWriter
with open('people.csv', 'r') as file:
    reader = csv.DictReader(file)
    for row in reader:
        print(f"{row['Name']} is {row['Age']} years old")
```

#### Working with JSON Files:

```python
import json

# Write JSON
data = {
    'name': 'Alice',
    'age': 25,
    'city': 'New York',
    'skills': ['Python', 'Data Analysis', 'Machine Learning']
}

with open('data.json', 'w') as file:
    json.dump(data, file, indent=4)

# Read JSON
with open('data.json', 'r') as file:
    loaded_data = json.load(file)
    print(loaded_data)
    print(f"Name: {loaded_data['name']}")
```

---

## Day 7: Exception Handling and Debugging

### Exception Handling

**Exceptions** are errors that occur during program execution. Proper handling prevents crashes.

#### Try-Except Block:

```python
# Basic try-except
try:
    number = int(input("Enter a number: "))
    result = 100 / number
    print(f"Result: {result}")
except ZeroDivisionError:
    print("Error: Cannot divide by zero!")
except ValueError:
    print("Error: Invalid input! Please enter a number.")

# Catch multiple exceptions
try:
    file = open('nonexistent.txt', 'r')
    content = file.read()
except (FileNotFoundError, PermissionError) as e:
    print(f"File error: {e}")

# Catch all exceptions
try:
    risky_operation()
except Exception as e:
    print(f"An error occurred: {e}")
```

#### Try-Except-Else-Finally:

```python
try:
    file = open('data.txt', 'r')
    content = file.read()
except FileNotFoundError:
    print("File not found!")
else:
    # Executes if no exception occurred
    print("File read successfully!")
    print(content)
finally:
    # Always executes, regardless of exceptions
    print("Cleanup: Closing resources")
    if 'file' in locals():
        file.close()
```

#### Raising Exceptions:

```python
def validate_age(age):
    """Validate age input"""
    if age < 0:
        raise ValueError("Age cannot be negative!")
    if age > 150:
        raise ValueError("Age seems unrealistic!")
    return True

try:
    validate_age(-5)
except ValueError as e:
    print(f"Validation error: {e}")

# Custom exceptions
class InsufficientFundsError(Exception):
    """Raised when account has insufficient funds"""
    pass

def withdraw(balance, amount):
    if amount > balance:
        raise InsufficientFundsError(f"Cannot withdraw ${amount}. Balance: ${balance}")
    return balance - amount

try:
    new_balance = withdraw(100, 150)
except InsufficientFundsError as e:
    print(e)
```

### Debugging Python

#### Using print() for Debugging:

```python
def calculate_average(numbers):
    print(f"DEBUG: Input numbers: {numbers}")  # Debug print
    total = sum(numbers)
    print(f"DEBUG: Total: {total}")  # Debug print
    count = len(numbers)
    print(f"DEBUG: Count: {count}")  # Debug print
    average = total / count
    return average

result = calculate_average([10, 20, 30, 40, 50])
print(f"Average: {result}")
```

#### Using assert for Debugging:

```python
def calculate_discount(price, discount_percent):
    assert 0 <= discount_percent <= 100, "Discount must be between 0 and 100"
    assert price > 0, "Price must be positive"
    
    discount = price * (discount_percent / 100)
    return price - discount

# This will raise AssertionError
# calculate_discount(100, 150)
```

#### Common Debugging Techniques:

```python
# 1. Type checking
def process_data(data):
    print(f"Type of data: {type(data)}")
    print(f"Data: {data}")

# 2. Checking variable values at different points
def complex_calculation(x, y):
    step1 = x * 2
    print(f"After step 1: {step1}")
    
    step2 = step1 + y
    print(f"After step 2: {step2}")
    
    result = step2 / 10
    print(f"Final result: {result}")
    return result

# 3. Using try-except to catch and display errors
def safe_divide(a, b):
    try:
        result = a / b
        return result
    except Exception as e:
        print(f"Error type: {type(e).__name__}")
        print(f"Error message: {e}")
        return None
```

### Revision: Functions

#### Key Concepts Summary:

```python
# 1. Basic function
def greet(name):
    return f"Hello, {name}!"

# 2. Default parameters
def power(base, exp=2):
    return base ** exp

# 3. *args and **kwargs
def flexible_func(*args, **kwargs):
    print(f"Args: {args}")
    print(f"Kwargs: {kwargs}")

# 4. Lambda function
square = lambda x: x ** 2

# 5. Recursive function
def factorial(n):
    return 1 if n <= 1 else n * factorial(n - 1)

# 6. File handling
with open('file.txt', 'r') as f:
    content = f.read()

# 7. Exception handling
try:
    risky_operation()
except Exception as e:
    print(f"Error: {e}")
finally:
    cleanup()
```

### Practice Exercises:

```python
# Exercise 1: Create a function to check if a number is prime
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

# Exercise 2: Read a file and count word frequency
def count_words(filename):
    word_count = {}
    try:
        with open(filename, 'r') as file:
            for line in file:
                words = line.lower().split()
                for word in words:
                    word_count[word] = word_count.get(word, 0) + 1
    except FileNotFoundError:
        print(f"File {filename} not found!")
    return word_count

# Exercise 3: Create a calculator with exception handling
def calculator():
    while True:
        try:
            num1 = float(input("Enter first number (or 'q' to quit): "))
            operation = input("Enter operation (+, -, *, /): ")
            num2 = float(input("Enter second number: "))
            
            if operation == '+':
                result = num1 + num2
            elif operation == '-':
                result = num1 - num2
            elif operation == '*':
                result = num1 * num2
            elif operation == '/':
                result = num1 / num2
            else:
                print("Invalid operation!")
                continue
            
            print(f"Result: {result}")
        except ValueError:
            print("Invalid input! Please enter numbers.")
        except ZeroDivisionError:
            print("Cannot divide by zero!")
        except KeyboardInterrupt:
            print("\nCalculator closed.")
            break
```

---

## Summary: Days 5-7

### What We Learned:

**Day 5 - Functions:**
- Function definition and syntax
- Types of functions (built-in, user-defined, lambda, higher-order)
- Function arguments (positional, keyword, default, *args, **kwargs)
- Recursive functions and their applications

**Day 6 - Lambda, Modules, and File Handling:**
- Lambda functions for concise code
- File operations (read, write, append)
- Working with CSV and JSON files
- File modes and best practices

**Day 7 - Exception Handling and Debugging:**
- Try-except-else-finally blocks
- Handling specific exceptions
- Raising custom exceptions
- Debugging techniques and best practices

### Key Takeaways:

1. Functions make code reusable and organized
2. Lambda functions are useful for short, simple operations
3. Always use `with` statement for file handling
4. Exception handling prevents program crashes
5. Debugging is an essential skill for finding and fixing errors

---
